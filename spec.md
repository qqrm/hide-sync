Ниже спецификация инструмента синхронизации скрытых тредов через GitHub Gist для браузерного расширения.

---

### 1. Назначение

Инструмент обеспечивает:

* Локальное скрытие тредов и разделов (форумов, веток, категорий) в интерфейсе сайта.
* Централизованное хранение состояния скрытия в одном JSON-файле в приватном GitHub Gist.
* Синхронизацию этого состояния между устройствами пользователя через Gist.

Целевая нагрузка:

* Один пользователь.
* Объем данных до 1 МБ на один JSON файл.

---

### 2. Акторы и окружение

* Пользователь:

  * Имеет аккаунт GitHub.
  * Создает персональный токен доступа (PAT) со scope `gist`.
* Браузерное расширение:

  * Desktop браузеры на Chromium и Firefox.
  * Состоит из background скрипта, content скриптов и options page.
* Внешние системы:

  * GitHub Gist API.

---

### 3. Требования к функционалу

3.1. Управление скрытием

* Расширение должно:

  * Перехватывать действия пользователя "Скрыть тред" и "Показать тред".
  * Перехватывать действия "Скрыть раздел" и "Показать раздел", если сайт поддерживает разделы.
  * Вносить изменения в локальное состояние скрытых элементов.
  * Немедленно отражать изменения в UI (DOM манипуляции).

3.2. Синхронизация

* При старте браузера или при загрузке страницы:

  * Расширение должно запросить актуальное состояние скрытых тредов из Gist.
  * Сохранить его в `browser.storage.local` для локального кеша.
* При изменении скрытого состояния:

  * Обновить локальный кеш.
  * В течение короткого интервала (например, debounce 2–5 секунд) отправить обновленный JSON в Gist.

3.3. Конфигурация токена

* В options page:

  * Поле для ввода PAT.
  * Кнопка "Проверить соединение":

    * Валидирует токен.
    * Проверяет наличие рабочего Gist.
    * При необходимости создает его.
* Токен хранится в `browser.storage.local` и не покидает браузер.

3.4. Работа без токена

* Если токен не настроен:

  * Расширение работает только с локальным хранилищем.
  * UI должен показывать статус "Синхронизация отключена".
* Состояние скрытия не синхронизируется между устройствами.

---

### 4. Модель данных

4.1. Структура JSON в Gist

```json
{
  "version": 1,
  "profiles": {
    "default": {
      "last_updated": "2025-11-16T10:00:00Z",
      "sites": {
        "example.com": {
          "threads": [
            "thread-id-1",
            "thread-id-2"
          ],
          "sections": [
            "section-id-foo",
            "section-id-bar"
          ]
        },
        "another-site.com": {
          "threads": ["12345"],
          "sections": []
        }
      }
    }
  }
}
```

Ключевые моменты:

* `version` нужен для возможной миграции схемы.
* `profiles` резерв под несколько профилей настроек пользователя в будущем.
* `sites` индекс по домену.
* Идентификаторы тредов и разделов определяются логикой маппинга в content скрипте:

  * Могут быть ID из DOM, URL, комбинации параметров.

4.2. Локальное хранилище

* В `browser.storage.local` хранится объект:

```json
{
  "token_present": true,
  "gist_id": "XXXXXXXXXXXX",
  "last_sync_at": "2025-11-16T10:00:00Z",
  "data": {
    "...": "копия структуры из Gist"
  }
}
```

---

### 5. Использование GitHub Gist

5.1. Тип Gist

* Gist должен быть:

  * Приватным.
  * Содержать один файл с фиксированным именем, например `hidden_threads.json`.

5.2. Создание Gist

* При первом успешном тесте токена:

  * Если Gist еще не существует:

    * Вызов `POST /gists` с телом:

      * `public: false`
      * `files.hidden_threads.json.content: "{}"` (или минимальная валидная структура JSON).
  * Сохранить `gist_id` в локальное хранилище.

5.3. Чтение Gist

* При старте расширения или при мастере синхронизации:

  * Вызов `GET /gists/{gist_id}`.
  * Извлечь содержимое `hidden_threads.json`.
  * Распарсить как JSON, сохранить в локальный кеш.

5.4. Обновление Gist

* При изменении данных:

  * Вызов `PATCH /gists/{gist_id}`:

    * `files.hidden_threads.json.content: "<строка JSON>"`.

5.5. Обработка конфликтов

* Сценарий: изменения с нескольких устройств в коротком интервале.
* Политика:

  * Принцип "последняя запись выигрывает".
  * Для минимизации конфликтов:

    * При загрузке страницы:

      * Всегда подтягивать свежие данные перед первой записью (если с момента последней синхронизации прошло более N секунд, например 30–60).
    * Хранить поле `last_updated` внутри JSON и проверять:

      * Если время на сервере "новее" локального, применять серверную версию и мерджить изменения по ключу `sites[domain]`.

---

### 6. Компоненты расширения

6.1. Content script

Ответственность:

* Интеграция с конкретным сайтом:

  * Нахождение DOM элементов тредов и разделов.
  * Присвоение стабильных идентификаторов.
  * Добавление UI элемента "Скрыть" / "Показать".
* Применение состояния:

  * Скрывать DOM элементы по спискам `threads` и `sections` из локального кеша.
* Отправка событий в background:

  * На "Скрыть тред": `HIDE_THREAD { domain, thread_id }`.
  * На "Показать тред": `UNHIDE_THREAD { domain, thread_id }`.
  * Аналогично для разделов.

6.2. Background script

Ответственность:

* Ядро синхронизации и логика работы с Gist.
* Поддержка API для content scripts через `runtime.onMessage`:

  * `GET_STATE { domain }` → возвращает списки `threads` и `sections` по домену.
  * `MUTATE_STATE` (hide/unhide) → обновляет локальное состояние и ставит задачу на синхронизацию с Gist.
* Работа с `browser.storage.local`:

  * Кеширование JSON.
  * Хранение токена и `gist_id`.
* Планировщик дебаунса записи:

  * Для серии операций скрытия применять один `PATCH` вместо множества.

6.3. Options page

Ответственность:

* UI для ввода и сохранения PAT.
* UI для запуска "Проверить соединение":

  * Проверка валидности токена через `GET /user`.
  * Проверка или создание Gist.
  * Загрузка начального состояния.
* Отображение статуса:

  * "Синхронизация включена / отключена".
  * Дата последней успешной синхронизации.
  * Ошибки работы с Gist.

---

### 7. Внутренний API модуля синхронизации

Предполагаемый интерфейс модуля `syncStorage` в background:

```ts
type DomainId = string;
type ThreadId = string;
type SectionId = string;

interface SiteState {
  threads: ThreadId[];
  sections: SectionId[];
}

interface StorageData {
  version: number;
  profiles: {
    [profileId: string]: {
      last_updated: string;
      sites: {
        [domain: string]: SiteState;
      };
    };
  };
}

interface SyncStorage {
  init(): Promise<void>;
  getSiteState(domain: DomainId): Promise<SiteState>;
  hideThread(domain: DomainId, threadId: ThreadId): Promise<void>;
  unhideThread(domain: DomainId, threadId: ThreadId): Promise<void>;
  hideSection(domain: DomainId, sectionId: SectionId): Promise<void>;
  unhideSection(domain: DomainId, sectionId: SectionId): Promise<void>;
}
```

---

### 8. Ошибки и деградация

* Если запрос к Gist не удался:

  * Продолжаем работать с последней локальной версией.
  * Пишем ошибку в лог и сохраняем статус ошибки в `browser.storage.local`.
  * Опционально показываем небольшое уведомление пользователю.
* Если JSON в Gist поврежден:

  * Логируем ошибку.
  * Не перетираем локальные данные.
  * Предлагаем пользователю в options page "пересоздать данные в Gist поверх текущего локального состояния".

---

### 9. Требования по безопасности

* PAT:

  * Никогда не коммитится в код.
  * Не отправляется на сторонние домены, только на `api.github.com`.
* Gist:

  * Создается приватным.
* Ограничение прав токена:

  * Токен должен иметь только scope `gist`.
* Логирование:

  * Не логировать токен.
  * Не логировать полное содержимое JSON, только метаданные и ошибки.

---

### 10. Расширяемость

В перспективе:

* Добавление профилей пользователя (`profiles`), привязанных к разным наборам сайтов или устройств.
* Поддержка альтернативных бекендов:

  * JSONBin, KVStore, Cloudflare Workers KV.
  * Через абстракцию `SyncBackend` с реализациями `GistBackend`, `JsonBinBackend` и так далее, без изменения логики content script.
